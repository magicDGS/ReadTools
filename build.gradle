// Dependencies for the buildscript (not the program)
buildscript {
    repositories {
        mavenCentral()
        jcenter() // for shadow plugin
    }
}

plugins {
    id "java"
    id "application"
    id "jacoco"
    id 'com.github.johnrengelman.shadow' version '1.2.3'
    id 'com.palantir.git-version' version '0.5.2' // for the git version
}

apply from: 'gradle/jacoco.coverage.gradle'

// No Windows support
startScripts {
    doLast {
        delete windowsScript
    }
}

group = 'org.magicdgs'
version = '1.0.0-SNAPSHOT'
description = """Tools for sequencing barcoded read data (in FASTQ/BAM format)"""

def developer = "Daniel Gomez-Sanchez"
def contact = "daniel.gomez.sanchez@hotmail.es"

sourceCompatibility = 1.8
targetCompatibility = 1.8

mainClassName = group + "." + rootProject.name.toLowerCase() + ".Main"

repositories {
    mavenCentral()
    maven {
        url "https://artifactory.broadinstitute.org/artifactory/libs-snapshot/"
    }
}
// versions for the dependencies
final gatkVersion = '4.alpha.2-181-g987e2f9-SNAPSHOT' // TODO: we should use the master-SNAPSHOT one is done (gatk/issue#1995)
final htsjdkVersion = '2.9.1-9-g6d22658-SNAPSHOT' // TODO: bring back to the HTSJDK release

dependencies {
    compile (group: 'org.broadinstitute', name: 'gatk', version: gatkVersion) {
        exclude module: 'jgrapht' // this is not required
        exclude module: 'htsjdk'
        exclude module: 'testng'
    }
    compile group: 'com.github.samtools', name: 'htsjdk', version: htsjdkVersion

    // compilation for testing
    testCompile 'org.testng:testng:6.11'
    testCompile 'org.mockito:mockito-core:1.10.19'
}

// for managing the wrapper task
task wrapper(type: Wrapper) {
    gradleVersion = '3.3'
}

tasks.withType(Jar) {
    def details = versionDetails()
    def buildNumber = (gitVersion().contains("dirty")) ? details.gitHash + ".dirty" : details.gitHash;
    def implementationVersion = project.version.replaceAll("-SNAPSHOT", "") + "_" +  buildNumber
    manifest {
        attributes 'Implementation-Title': rootProject.name,
            'Implementation-Version': implementationVersion,
            'Main-Class': project.mainClassName
    }
}

// test task
tasks.withType(Test) {

    // tests could be always re-run
    outputs.upToDateWhen { false }
    String TEST_VERBOSITY = "$System.env.TEST_VERBOSITY"

    useTestNG()

    // TODO: set a system property for the test JVM(s)
    // TODO: example -> systemProperty 'some.prop', 'value'

    // show the stdout/stderr of the test JVM(s) on the console
    testLogging.showStandardStreams = true

    // set heap size for the test JVM(s)
    minHeapSize = "1G"
    maxHeapSize = "2G"

    // TODO: set JVM arguments for the test JVM(s)
    // TODO: example -> jvmArgs '-XX:MaxPermSize=256m'

    if (TEST_VERBOSITY == "minimal") {
        int count = 0
        // listen to events in the test execution lifecycle
        logger.lifecycle("Minimal test verbosity");

        beforeTest { descriptor ->
            count++
            if( count % 100 == 0) {
                logger.lifecycle("Finished "+ Integer.toString(count) + " tests")
            }
        }
    } else {
        // log the test that is running
        beforeTest { descriptor ->
            logger.lifecycle("Running Test: " + descriptor)
        }

        // listen to standarrd out and standard error of the test JVM(s)
        def testOutput = ""
        onOutput { descriptor, event ->
            logger.lifecycle("Test: " + descriptor + " standard out/err -> " + event.message)
        }
    }

    // logging after the tests
    testLogging {
        testLogging {
            events "skipped", "failed"
            exceptionFormat = "full"
        }
        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                println "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
            }
        }
    }
}

processResources {
    def details = versionDetails()
    // this is better for having a "dirty" marker for versions
    def buildNumber = (gitVersion().contains("dirty")) ? details.gitHash + ".dirty" : details.gitHash;
    // get the timestamp in its format
    def date = new Date()
    def timestamp = date.format('yyyy-MM-dd HH:mm:ss')
    expand(name: project.name,
        version: project.version.replaceAll("-SNAPSHOT", ""),
        buildNumber: buildNumber,
        timestamp: timestamp,
        developer: developer,
        contact: contact) 
}


processTestResources {
    // do not package our test data into the test jar
    exclude "**/org/magicdgs/readtools/**"
}

shadowJar {
    zip64 true
    classifier = null
    version = null
    mergeServiceFiles()
}
